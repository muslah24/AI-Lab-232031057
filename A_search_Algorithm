import heapq

def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def get_neighbors(pos, grid):
    directions = [(0,1), (1,0), (0,-1), (-1,0)]
    neighbors = []
    for dx, dy in directions:
        nx, ny = pos[0] + dx, pos[1] + dy
        if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]) and grid[nx][ny] == 0:
            neighbors.append((nx, ny))
    return neighbors

def build_path(parent, node):
    path = [node]
    while node in parent:
        node = parent[node]
        path.append(node)
    return list(reversed(path))

def a_star_search(grid, start, goal):
    open_list = []
    heapq.heappush(open_list, (0 + manhattan(start, goal), start))
    g_cost = {start: 0}
    parent = {}

    while open_list:
        _, current = heapq.heappop(open_list)

        if current == goal:
            return build_path(parent, current)

        for neighbor in get_neighbors(current, grid):
            new_cost = g_cost[current] + 1
            if neighbor not in g_cost or new_cost < g_cost[neighbor]:
                g_cost[neighbor] = new_cost
                f_cost = new_cost + manhattan(neighbor, goal)
                parent[neighbor] = current
                heapq.heappush(open_list, (f_cost, neighbor))

    return None

if __name__ == "__main__":
    grid = [
        [0,0,0,0,0],
        [1,1,0,1,0],
        [0,0,0,1,0],
        [0,1,1,1,0],
        [0,0,0,0,0]
    ]
    start = (0,0)
    goal = (4,4)
    print("A* Search Path:", a_star_search(grid, start, goal))
